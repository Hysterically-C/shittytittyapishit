local replicatedstorage = game:GetService("ReplicatedStorage")

local library = loadstring(game:HttpGet('https://raw.githubusercontent.com/ovoch228/depthsoimgui/refs/heads/main/library'))()
local bytenet = require(replicatedstorage:WaitForChild("Teawork"):WaitForChild("Shared"):WaitForChild("Services"):WaitForChild("ByteNetworking"))

local api = {}

local FAST_WAIT = 0.03

function api:Loadout(towers)
	if game.PlaceId ~= 98936097545088 then return end
	for i = 1, #towers do
		local attempt = 0
		while true do
			if env and env.isroundover then return end
			attempt = attempt + 1
			local ok, res = pcall(function()
				return bytenet.Inventory.EquipTower.invoke({["TowerID"] = towers[i], ["Slot"] = i})
			end)
			if ok then
				updatelog("Loadout: Equipped " .. tostring(towers[i]) .. " (slot " .. tostring(i) .. ") after " .. tostring(attempt) .. " attempt(s)")
				break
			else
				updatelog("Loadout: Equip failed for " .. tostring(towers[i]) .. " attempt " .. tostring(attempt) .. " - retrying")
				task.wait(FAST_WAIT)
			end
		end
		task.wait(FAST_WAIT)
	end
end

function api:Map(map, modifiers)
	if game.PlaceId ~= 98936097545088 then return end
	local attempt = 0
	while true do
		if env and env.isroundover then return end
		attempt = attempt + 1
		local ok, res = pcall(function()
			return bytenet.MatchmakingNew.CreateSingleplayer.invoke({["Gamemode"] = "Standard", ["MapID"] = map, ["Modifiers"] = modifiers})
		end)
		if ok then
			updatelog("Map: Created singleplayer match for " .. tostring(map) .. " after " .. tostring(attempt) .. " attempt(s)")
			break
		else
			updatelog("Map: CreateSingleplayer failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

if game.PlaceId ~= 124069847780670 then return api end

local towers = bytenet.Towers
local mapinfo = replicatedstorage.RoundInfo
local roundresultui = game:GetService("Players").LocalPlayer.PlayerGui.GameUI.RoundResult

local ostime = os.time
local taskwait = task.wait
local env = getgenv()

-- env defaults
env.StratName = "Strat"
env.timer = 0
env.lasttime = ostime()
env.waveinfo = 1
env.isroundover = false
env.totalplacedtowers = 0
env.firsttower = 1
env.destroyui = false
env.chosenDifficulty = nil -- will be set when difficulty is voted/recorded

local window = library:CreateWindow({
	Title = "Shitty X",
	Size = UDim2.new(0, 350, 0, 370),
	Position = UDim2.new(0.5, 0, 0, 70),
	NoResize = false
})
window:Center()

local logtab = window:CreateTab({ Name = "Macro Player", Visible = true })
local filename = logtab:Label({ Text = "StratName: " .. env.StratName })

local logstab = window:CreateTab({ Name = "Logs", Visible = true })
local loglabel = logtab:Label({ Label = "Last Log: Voting" })

local row = logstab:Row()
logstab:Separator({ Text = "Logs:" })

local logs = logstab:Console({
	Text = "",
	ReadOnly = true,
	LineNumbers = false,
	Border = false,
	Fill = true,
	Enabled = true,
	AutoScroll = true,
	RichText = true,
	MaxLines = 200
})

function updatelog(text)
	setthreadidentity(7)
	logs:AppendText(DateTime.now():FormatLocalTime("HH:mm:ss", "en-us") .. ": " .. tostring(text))
	loglabel:SetText("Last Log: " .. tostring(text))
end

window:ShowTab(logtab)
updatelog("Voting")

-- waitTime polls wave/timer without blocking server RPC retries
function waitTime(time, wave)
	while env.waveinfo < wave and not env.isroundover do
		task.wait(FAST_WAIT)
	end
	while env.timer < time and not env.isroundover do
		task.wait(FAST_WAIT)
	end
	return not env.isroundover
end

function api:Loop(func)
	if game.PlaceId ~= 124069847780670 then return end
	while task.wait(FAST_WAIT) do
		func()
	end
end

function api:Start()
	-- speed up local timescale
	pcall(function() bytenet.Timescale.SetTimescale.send(3) end)

	env.waveinfo = mapinfo:GetAttribute("Wave") or 1
	env.timer = 0

	-- keep wave info updated
	mapinfo:GetAttributeChangedSignal("Wave"):Connect(function()
		env.waveinfo = mapinfo:GetAttribute("Wave")
	end)

	-- detect round end
	roundresultui:GetPropertyChangedSignal("Visible"):Connect(function()
		env.isroundover = roundresultui.Visible
	end)

	updatelog("Game Started")
	task.spawn(function()
		env.lasttime = ostime()
		while true do
			if not env.lasttime then break end
			env.timer = (ostime() - env.lasttime) * 3
			task.wait(0.25)
		end
	end)
end

-- Helper: wait until RoundInfo difficulty attribute is non-empty (works for string or table)
local function waitForDifficulty(timeout)
	local start = tick()
	while not env.isroundover do
		local d = mapinfo:GetAttribute("Difficulty")
		if d ~= nil then
			local t = type(d)
			if (t == "string" and d ~= "") or (t == "table" and #d > 0) then
				return d
			end
		end
		if timeout and (tick() - start) >= timeout then break end
		task.wait(FAST_WAIT)
	end
	return nil
end

function api:Difficulty(diff)
	-- diff should be whatever the server expects (string/number). we pass through as-is.
	updatelog("Voted difficulty " .. tostring(diff))

	-- Keep trying to send vote until RPC succeeds or round ends
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, err = pcall(function() bytenet.DifficultyVote.Vote.send(diff) end)
		if ok then
			updatelog("Difficulty vote sent after " .. tostring(attempt) .. " attempt(s)")
			break
		else
			updatelog("Difficulty vote failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end

	-- Wait for the server to reflect the chosen difficulty in RoundInfo
	local recorded = waitForDifficulty(6) -- 6s timeout fallback
	if recorded then
		env.chosenDifficulty = recorded
		updatelog("Recorded difficulty: " .. tostring(recorded))
	else
		-- fallback: read attribute once more; if still empty, record the local diff we sent
		local final = mapinfo:GetAttribute("Difficulty")
		if final and ((type(final) == "string" and final ~= "") or (type(final) == "table" and #final > 0)) then
			env.chosenDifficulty = final
			updatelog("Recorded difficulty (late): " .. tostring(final))
		else
			env.chosenDifficulty = diff
			updatelog("Difficulty attribute not observed; saved requested diff: " .. tostring(diff))
		end
	end

	-- reset timers/wave state for macro playback
	env.lasttime = ostime()
	env.timer = 0
	env.waveinfo = 1
	task.wait(FAST_WAIT)
end

function api:Ready(time, wave)
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, err = pcall(function() bytenet.ReadyVote.Vote.send(true) end)
		if ok then
			updatelog("Sent ready vote after " .. tostring(attempt) .. " attempt(s)")
			break
		else
			updatelog("Ready vote failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

function api:Skip(time, wave)
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, err = pcall(function() replicatedstorage:WaitForChild("ByteNetReliable"):FireServer(buffer.fromstring("\148\001")) end)
		if ok then
			updatelog("Skip sent after " .. tostring(attempt) .. " attempt(s)")
			break
		else
			updatelog("Skip failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

function api:AutoSkip(enable, time, wave)
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, err = pcall(function() bytenet.SkipWave.ToggleAutoSkip.send(enable) end)
		if ok then
			updatelog("AutoSkip set to " .. tostring(enable) .. " after " .. tostring(attempt) .. " attempt(s)")
			break
		else
			updatelog("AutoSkip failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

function api:Place(tower, position, time, wave)
	env.totalplacedtowers = env.totalplacedtowers + 1
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, res = pcall(function()
			return towers.PlaceTower.invoke({["Position"] = position, ["Rotation"] = 0, ["TowerID"] = tower})
		end)
		if ok then
			if type(res) == "table" then
				if res.Success == true then
					updatelog("Placed Tower " .. tostring(tower) .. " (attempt " .. tostring(attempt) .. ")")
					break
				else
					updatelog("Place returned failure; retrying (attempt " .. tostring(attempt) .. ")")
					task.wait(FAST_WAIT)
				end
			else
				updatelog("Placed Tower " .. tostring(tower) .. " (attempt " .. tostring(attempt) .. ")")
				break
			end
		else
			updatelog("Place invocation error attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

function api:Upgrade(tower, targetLevel, time, wave)
	local realindex = env.firsttower + (tower - 1)
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, res = pcall(function()
			return towers.UpgradeTower.invoke(realindex)
		end)
		if ok then
			if type(res) == "table" then
				if res.Success == true then
					if res.Level then
						updatelog("Upgraded Tower " .. tostring(tower) .. " to Level " .. tostring(res.Level) .. " (attempt " .. tostring(attempt) .. ")")
						if targetLevel == nil or res.Level == targetLevel then
							break
						else
							task.wait(FAST_WAIT)
						end
					else
						updatelog("Upgraded Tower " .. tostring(tower) .. " (attempt " .. tostring(attempt) .. ")")
						break
					end
				else
					local reason = res.FailReason or "Unknown"
					updatelog("Upgrade failed (" .. tostring(reason) .. ") attempt " .. tostring(attempt) .. " - retrying")
					task.wait(FAST_WAIT)
				end
			else
				updatelog("Upgraded Tower " .. tostring(tower) .. " (attempt " .. tostring(attempt) .. ")")
				break
			end
		else
			updatelog("Upgrade invocation error attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

function api:SetTarget(tower, target, time, wave)
	local realindex = env.firsttower + (tower - 1)
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, err = pcall(function() towers.SetTargetMode.send({["UID"] = (realindex), ["TargetMode"] = target}) end)
		if ok then
			updatelog("Changed Tower " .. tostring(tower) .. " Target to " .. tostring(target) .. " (attempt " .. tostring(attempt) .. ")")
			break
		else
			updatelog("SetTarget failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

function api:Sell(tower, time, wave)
	local realindex = env.firsttower + (tower - 1)
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, res = pcall(function() return towers.SellTower.invoke(realindex) end)
		if ok then
			updatelog("Sold Tower " .. tostring(tower) .. " (attempt " .. tostring(attempt) .. ")")
			break
		else
			updatelog("Sell failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

function api:PlayAgain()
	while not env.isroundover do task.wait(FAST_WAIT) end
	env.firsttower = env.totalplacedtowers + 1
	env.lasttime = ostime()
	env.timer = 0
	env.waveinfo = 1
	task.wait(1)
	local attempt = 0
	while true do
		attempt = attempt + 1
		local ok, err = pcall(function() bytenet.RoundResult.VoteForRestart.send(true) end)
		if ok then
			updatelog("Voted for restart after " .. tostring(attempt) .. " attempt(s)")
			break
		else
			updatelog("PlayAgain vote failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

return api
