local replicatedstorage = game:GetService("ReplicatedStorage")
local library = loadstring(game:HttpGet('https://raw.githubusercontent.com/ovoch228/depthsoimgui/refs/heads/main/library'))()

local teamwork = replicatedstorage:WaitForChild("Teawork", 10)
local bytenet = require(teamwork:WaitForChild("Shared"):WaitForChild("Services"):WaitForChild("ByteNetworking"))

local api = {}

if game.PlaceId ~= 124069847780670 then return api end

local towers = bytenet.Towers
local mapinfo = replicatedstorage.RoundInfo
local roundresultui = game:GetService("Players").LocalPlayer.PlayerGui.GameUI.RoundResult

local ostime = os.time
local taskwait = task.wait
local env = getgenv()

env.StratName = "Strat"
env.timer = 0
env.lasttime = ostime()
env.waveinfo = 1
env.isroundover = false

env.TowerMap = {}
env.CurrentMacroIndex = 0
env.TotalPlacedCount = 0

local window = library:CreateWindow({
    Title = "Fail-Safe Macro",
    Size = UDim2.new(0, 350, 0, 370),
    Position = UDim2.new(0.5, 0, 0, 70)
})
window:Center()

local logtab = window:CreateTab({ Name = "Macro Player", Visible = true })
local logstab = window:CreateTab({ Name = "Logs", Visible = true })

local statusLabel = logtab:Label({ Text = "Status: Idle" })
local logs = logstab:Console({
    Text = "",
    ReadOnly = true,
    AutoScroll = true,
    RichText = true,
    MaxLines = 300
})

local function updatelog(text)
    setthreadidentity(7)
    logs:AppendText(DateTime.now():FormatLocalTime("HH:mm:ss", "en-us") .. " | " .. text)
    statusLabel:SetText("Status: " .. text)
end

local function debugprint(tag, value)
    local t = typeof(value)
    if t == "table" then
        local keys = {}
        for k in pairs(value) do
            keys[#keys+1] = tostring(k)
        end
        updatelog(`[DEBUG:{tag}] table -> {{{table.concat(keys,", ")}}}`)
    else
        updatelog(`[DEBUG:{tag}] {t} -> {tostring(value)}`)
    end
end

window:ShowTab(logtab)
updatelog("Waiting for Game...")

local cachedFolder
local function GetTowersFolder()
    if cachedFolder then return cachedFolder end
    local possible = {
        workspace:FindFirstChild("Towers"),
        workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Towers"),
        workspace:FindFirstChild("Ignore") and workspace.Ignore:FindFirstChild("Towers"),
        workspace:FindFirstChild("Units"),
        workspace:FindFirstChild("PlacedTowers")
    }
    for _, f in ipairs(possible) do
        if f then cachedFolder = f return f end
    end
end

local function waitTime(time, wave)
    while env.waveinfo < wave and not env.isroundover do taskwait(0.1) end
    while env.timer < time and not env.isroundover do taskwait(0.05) end
    return not env.isroundover
end

function api:Start()
    bytenet.Timescale.SetTimescale.send(3)
    env.waveinfo = mapinfo:GetAttribute("Wave") or 1
    env.timer = 0
    env.TowerMap = {}
    env.CurrentMacroIndex = 0
    env.TotalPlacedCount = 0
    cachedFolder = nil

    mapinfo:GetAttributeChangedSignal("Wave"):Connect(function()
        env.waveinfo = mapinfo:GetAttribute("Wave")
    end)

    roundresultui:GetPropertyChangedSignal("Visible"):Connect(function()
        env.isroundover = roundresultui.Visible
    end)

    task.spawn(function()
        env.lasttime = ostime()
        while true do
            env.timer = (ostime() - env.lasttime) * 3
            taskwait(0.1)
        end
    end)

    updatelog("Macro Started")
end

function api:Place(tower, position, time, wave)
    if not waitTime(time, wave) then return end

    env.CurrentMacroIndex += 1
    local idx = env.CurrentMacroIndex
    updatelog(`Placing {tower} (Step {idx})`)

    local folder = GetTowersFolder()
    local before = {}
    if folder then
        for _, c in ipairs(folder:GetChildren()) do before[c] = true end
    end

    local finalUID
    local tries = 0

    repeat
        if env.isroundover then return end
        local ok, res = pcall(function()
            return towers.PlaceTower.invoke({
                Position = position,
                Rotation = 0,
                TowerID = tower
            })
        end)

        debugprint("PlaceReturn", res)

        if ok and type(res) == "number" then
            finalUID = res
        elseif ok and type(res) == "table" then
            finalUID = res.UID or res.uid or res.Id or res.ID
        end

        if not finalUID and folder then
            taskwait(0.15)
            for _, c in ipairs(folder:GetChildren()) do
                if not before[c] then
                    finalUID =
                        tonumber(c.Name) or
                        c:GetAttribute("UID") or
                        (c:FindFirstChild("UID") and c.UID.Value)
                    break
                end
            end
        end

        if not finalUID then
            tries += 1
            taskwait(0.2)
        end
    until finalUID or tries > 4

    if not finalUID then
        env.TotalPlacedCount += 1
        finalUID = env.TotalPlacedCount
        updatelog("Blind UID fallback used")
    end

    env.TowerMap[idx] = finalUID
    updatelog(`Placed {tower} UID={finalUID}`)
end

function api:Upgrade(towerIndex, time, wave)
    if not waitTime(time, wave) then return end

    local uid = env.TowerMap[towerIndex] or towerIndex
    updatelog(`Upgrading UID={uid}`)

    local attempts = {
        function() return towers.UpgradeTower.invoke(uid) end,
        function() return towers.UpgradeTower.invoke({ UID = uid }) end,
        function() return towers.UpgradeTower.send(uid) end,
        function() return towers.UpgradeTower.send({ UID = uid }) end
    }

    for i, fn in ipairs(attempts) do
        if env.isroundover then return end
        local ok, res = pcall(fn)
        debugprint("UpgradeAttempt"..i, res)
        if ok and (res == nil or res == true or (type(res)=="table" and res.Success)) then
            updatelog(`Upgrade Success UID={uid}`)
            return
        end
        taskwait(0.12)
    end

    updatelog(`Upgrade FAILED UID={uid}`)
end

function api:SetTarget(towerIndex, target, time, wave)
    if not waitTime(time, wave) then return end
    towers.SetTargetMode.send({
        UID = env.TowerMap[towerIndex] or towerIndex,
        TargetMode = target
    })
end

function api:Sell(towerIndex, time, wave)
    if not waitTime(time, wave) then return end
    towers.SellTower.invoke(env.TowerMap[towerIndex] or towerIndex)
end

function api:Loop(func)
    while taskwait(0.03) do func() end
end

function api:PlayAgain()
    while not env.isroundover do taskwait(0.1) end
    env.lasttime = ostime()
    env.timer = 0
    env.waveinfo = 1
    taskwait(1)
    bytenet.RoundResult.VoteForRestart.send(true)
end

return api
