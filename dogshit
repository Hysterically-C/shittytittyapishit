if game.PlaceId ~= 124069847780670 then return api end

local towers = bytenet.Towers
local mapinfo = replicatedstorage.RoundInfo
local roundresultui = game:GetService("Players").LocalPlayer.PlayerGui.GameUI.RoundResult
local datamodule = require(client.Services.DataSync)

local ostime = os.time
local taskwait = task.wait
local env = getgenv()

env.timer = 0
env.waveinfo = 1
env.isroundover = false
env.lasttime = ostime()

env.towers = {} -- [uid] = towerdata
env.fail = function(msg)
	error("[MACRO FAIL] "..msg)
end

-- listen for tower replication
local function attachTowerListeners()
	local events = {"OnTowerAdded","TowerAdded","OnTowerUpdated","TowerUpdated","Update","OnUpdate"}
	for _,n in ipairs(events) do
		if towers[n] and towers[n].listen then
			towers[n].listen(function(t)
				if t and t.UID then
					env.towers[t.UID] = t
				end
			end)
		end
	end
end
attachTowerListeners()

-- timer
task.spawn(function()
	while true do
		env.timer = (ostime() - env.lasttime) * 3
		taskwait(0.25)
	end
end)

mapinfo:GetAttributeChangedSignal("Wave"):Connect(function()
	env.waveinfo = mapinfo:GetAttribute("Wave")
end)

roundresultui:GetPropertyChangedSignal("Visible"):Connect(function()
	env.isroundover = roundresultui.Visible
end)

local function waitTime(t, w)
	while env.waveinfo < w and not env.isroundover do taskwait(0.05) end
	while env.timer < t and not env.isroundover do taskwait(0.05) end
	return not env.isroundover
end

local function waitForTowerAt(pos, towerid, timeout)
	local endt = os.clock() + timeout
	while os.clock() < endt do
		for uid,t in pairs(env.towers) do
			if t.TowerID == towerid and (t.Position - pos).Magnitude < 1.5 then
				return uid, t
			end
		end
		taskwait(0.05)
	end
end

function api:Start()
	bytenet.Timescale.SetTimescale.send(3)
	env.lasttime = ostime()
	env.timer = 0
	env.waveinfo = mapinfo:GetAttribute("Wave") or 1
end

function api:Difficulty(diff)
	bytenet.DifficultyVote.Vote.send(diff)
	while #mapinfo:GetAttribute("Difficulty") == 0 do taskwait(0.05) end
	env.lasttime = ostime()
	env.timer = 0
	env.waveinfo = 1
end

function api:PlaceUID(tower, pos, uid, time, wave)
	if not waitTime(time, wave) then return end

	towers.PlaceTower.invoke({
		Position = pos,
		Rotation = 0,
		TowerID = tower
	})

	local foundUID = uid or select(1, waitForTowerAt(pos, tower, 3))
	if not foundUID then
		-- retry once
		towers.PlaceTower.invoke({
			Position = pos,
			Rotation = 0,
			TowerID = tower
		})
		foundUID = select(1, waitForTowerAt(pos, tower, 2))
	end

	if not foundUID then
		env.fail("Placement failed: "..tower)
	end
end

function api:UpgradeUID(uid, time, wave)
	if not waitTime(time, wave) then return end

	local t = env.towers[uid]
	if not t then env.fail("Upgrade target missing UID "..uid) end

	local prev = t.Level
	towers.UpgradeTower.invoke(uid)

	local endt = os.clock() + 2
	while os.clock() < endt do
		if env.towers[uid] and env.towers[uid].Level > prev then
			return
		end
		taskwait(0.05)
	end

	-- retry once
	towers.UpgradeTower.invoke(uid)
	endt = os.clock() + 1
	while os.clock() < endt do
		if env.towers[uid] and env.towers[uid].Level > prev then
			return
		end
		taskwait(0.05)
	end

	env.fail("Upgrade failed UID "..uid)
end

function api:SetTarget(uid, target, time, wave)
	if waitTime(time, wave) then
		towers.SetTargetMode.send({UID = uid, TargetMode = target})
	end
end

function api:Sell(uid, time, wave)
	if waitTime(time, wave) then
		towers.SellTower.invoke(uid)
	end
end

function api:PlayAgain()
	while not env.isroundover do taskwait(0.1) end
	env.lasttime = ostime()
	env.timer = 0
	env.waveinfo = 1
	bytenet.RoundResult.VoteForRestart.send(true)
end

return api
