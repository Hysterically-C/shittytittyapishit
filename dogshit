local replicatedstorage = game:GetService("ReplicatedStorage")
local library = loadstring(game:HttpGet('https://raw.githubusercontent.com/ovoch228/depthsoimgui/refs/heads/main/library'))()

local teamwork = replicatedstorage:WaitForChild("Teawork", 10)
local bytenet = require(teamwork:WaitForChild("Shared"):WaitForChild("Services"):WaitForChild("ByteNetworking"))

local api = {}

if game.PlaceId ~= 124069847780670 then return api end

local towers = bytenet.Towers
local mapinfo = replicatedstorage.RoundInfo
local roundresultui = game:GetService("Players").LocalPlayer.PlayerGui.GameUI.RoundResult

local ostime = os.time
local taskwait = task.wait
local env = getgenv()

env.StratName = "Strat"
env.timer = 0
env.lasttime = ostime()
env.waveinfo = 1
env.isroundover = false

env.TowerMap = {}
env.CurrentMacroIndex = 0
env.TotalPlacedCount = 0

local window = library:CreateWindow({
    Title = "Fail-Safe Macro",
    Size = UDim2.new(0, 350, 0, 370),
    Position = UDim2.new(0.5, 0, 0, 70)
})
window:Center()

local logtab = window:CreateTab({ Name = "Macro Player", Visible = true })
local logstab = window:CreateTab({ Name = "Logs", Visible = true })

local statusLabel = logtab:Label({ Text = "Status: Idle" })
local logs = logstab:Console({
    Text = "",
    ReadOnly = true,
    AutoScroll = true,
    RichText = true,
    MaxLines = 400
})

local function updatelog(text)
    pcall(function() setthreadidentity(7) end)
    local stamp = DateTime.now():FormatLocalTime("HH:mm:ss", "en-us")
    logs:AppendText(stamp .. " | " .. tostring(text))
    pcall(function() statusLabel:SetText("Status: " .. tostring(text)) end)
end

local function debugprint(tag, val)
    local t = typeof(val)
    if t == "table" then
        local keys = {}
        for k in pairs(val) do keys[#keys+1] = tostring(k) end
        updatelog(string.format("[DEBUG:%s] table keys = {%s}", tostring(tag), table.concat(keys, ", ")))
    else
        updatelog(string.format("[DEBUG:%s] %s -> %s", tostring(tag), t, tostring(val)))
    end
end

window:ShowTab(logtab)
updatelog("Waiting for Game...")

local cachedFolder
local function GetTowersFolder()
    if cachedFolder then return cachedFolder end
    local possible = {
        workspace:FindFirstChild("Towers"),
        workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Towers"),
        workspace:FindFirstChild("Ignore") and workspace.Ignore:FindFirstChild("Towers"),
        workspace:FindFirstChild("Units"),
        workspace:FindFirstChild("PlacedTowers")
    }
    for _, f in ipairs(possible) do
        if f then
            cachedFolder = f
            updatelog("Found Towers folder: " .. f:GetFullName())
            return f
        end
    end
    updatelog("Towers folder not found")
    return nil
end

local function waitTime(time, wave)
    while env.waveinfo < wave and not env.isroundover do taskwait(0.1) end
    while env.timer < time and not env.isroundover do taskwait(0.05) end
    return not env.isroundover
end

function api:Start()
    if towers and towers.SetTimescale and towers.SetTimescale.send then
        pcall(function() towers.SetTimescale.send(3) end)
    elseif bytenet.Timescale and bytenet.Timescale.SetTimescale and bytenet.Timescale.SetTimescale.send then
        pcall(function() bytenet.Timescale.SetTimescale.send(3) end)
    end

    env.waveinfo = mapinfo:GetAttribute("Wave") or 1
    env.timer = 0
    env.TowerMap = {}
    env.CurrentMacroIndex = 0
    env.TotalPlacedCount = 0
    cachedFolder = nil

    mapinfo:GetAttributeChangedSignal("Wave"):Connect(function()
        env.waveinfo = mapinfo:GetAttribute("Wave")
    end)

    roundresultui:GetPropertyChangedSignal("Visible"):Connect(function()
        env.isroundover = roundresultui.Visible
    end)

    task.spawn(function()
        env.lasttime = ostime()
        while true do
            env.timer = (ostime() - env.lasttime) * 3
            taskwait(0.1)
        end
    end)

    updatelog("Macro Started")
end

-- safe-call helper
local function safeCall(fn, ...)
    if type(fn) ~= "function" then
        return false, ("fn_not_function")
    end
    local ok, res = pcall(fn, ...)
    return ok, res
end

function api:Place(tower, position, time, wave)
    if not waitTime(time, wave) then return end

    env.CurrentMacroIndex = env.CurrentMacroIndex + 1
    local idx = env.CurrentMacroIndex
    updatelog(string.format("Placing %s (Step %d)...", tostring(tower), idx))

    local folder = GetTowersFolder()
    local before = {}
    if folder then
        for _, c in ipairs(folder:GetChildren()) do before[c] = true end
    end

    local finalUID
    local tries = 0

    repeat
        if env.isroundover then return end

        local ok, res = safeCall((towers and towers.PlaceTower and towers.PlaceTower.invoke) or nil, {
            Position = position,
            Rotation = 0,
            TowerID = tower
        })

        debugprint("PlaceReturn", res)

        if ok and type(res) == "number" then
            finalUID = res
            updatelog("Place returned numeric UID: " .. tostring(finalUID))
        elseif ok and type(res) == "table" then
            finalUID = res.UID or res.uid or res.Id or res.ID
            if finalUID then updatelog("Place returned table UID: " .. tostring(finalUID)) end
        end

        if not finalUID and folder then
            taskwait(0.15)
            for _, c in ipairs(folder:GetChildren()) do
                if not before[c] then
                    local found = tonumber(c.Name) or (c.GetAttribute and c:GetAttribute("UID")) or (c:FindFirstChild("UID") and c.UID.Value)
                    if type(found) == "number" then
                        finalUID = found
                        updatelog("Detected new instance in workspace, UID: " .. tostring(finalUID))
                        break
                    else
                        -- if count increased and we couldn't find a UID, accept heuristic
                        if #folder:GetChildren() > (table.maxn(before) or 0) then
                            env.TotalPlacedCount = env.TotalPlacedCount + 1
                            finalUID = env.TotalPlacedCount
                            updatelog("Heuristic placement: assigned fake UID: " .. tostring(finalUID))
                            break
                        end
                    end
                end
            end
        end

        if not finalUID then
            tries = tries + 1
            if tries > 4 then
                env.TotalPlacedCount = env.TotalPlacedCount + 1
                finalUID = env.TotalPlacedCount
                updatelog("Blind fallback used, assigned UID: " .. tostring(finalUID))
                break
            end
            taskwait(0.25)
        end
    until finalUID

    env.TowerMap[idx] = finalUID
    updatelog(string.format("Placed %s UID=%s", tostring(tower), tostring(finalUID)))
end

function api:Upgrade(towerIndex, time, wave)
    if not waitTime(time, wave) then return end

    local uid = env.TowerMap[towerIndex] or towerIndex
    updatelog("Upgrading UID=" .. tostring(uid))

    local attempts = {
        { fn = towers and towers.UpgradeTower and towers.UpgradeTower.invoke, arg = uid },
        { fn = towers and towers.UpgradeTower and towers.UpgradeTower.invoke, arg = { UID = uid } },
        { fn = towers and towers.UpgradeTower and towers.UpgradeTower.send, arg = uid },
        { fn = towers and towers.UpgradeTower and towers.UpgradeTower.send, arg = { UID = uid } },
        -- fallback to bytenet style variations
        { fn = bytenet and bytenet.UpgradeTower and bytenet.UpgradeTower.invoke, arg = uid },
        { fn = bytenet and bytenet.UpgradeTower and bytenet.UpgradeTower.invoke, arg = { UID = uid } }
    }

    for i, at in ipairs(attempts) do
        if env.isroundover then return end
        local fn = at.fn
        local arg = at.arg
        if type(fn) ~= "function" then
            debugprint("UpgradeAttempt"..i, "fn_missing")
        else
            local ok, res
            if type(arg) == "table" then
                ok, res = safeCall(fn, arg)
            else
                ok, res = safeCall(fn, arg)
            end
            debugprint("UpgradeAttempt"..i, res)
            if ok and (res == nil or res == true or (type(res) == "table" and (res.Success == true or res.success == true))) then
                updatelog("Upgrade Success UID=" .. tostring(uid))
                return
            end
        end
        taskwait(0.12)
    end

    updatelog("Upgrade FAILED UID=" .. tostring(uid))
end

function api:SetTarget(towerIndex, target, time, wave)
    if not waitTime(time, wave) then return end
    local uid = env.TowerMap[towerIndex] or towerIndex
    local args = { UID = uid, TargetMode = target }
    if towers and towers.SetTargetMode and towers.SetTargetMode.send then
        pcall(function() towers.SetTargetMode.send(args) end)
    elseif towers and towers.SetTargetMode and towers.SetTargetMode.invoke then
        pcall(function() towers.SetTargetMode.invoke(args) end)
    else
        pcall(function() bytenet.Towers.SetTargetMode.send(args) end)
    end
end

function api:Sell(towerIndex, time, wave)
    if not waitTime(time, wave) then return end
    local uid = env.TowerMap[towerIndex] or towerIndex
    if towers and towers.SellTower and towers.SellTower.invoke then
        pcall(function() towers.SellTower.invoke(uid) end)
    elseif towers and towers.SellTower and towers.SellTower.send then
        pcall(function() towers.SellTower.send(uid) end)
    else
        pcall(function() bytenet.Towers.SellTower.invoke(uid) end)
    end
    updatelog("Sold UID=" .. tostring(uid))
end

function api:Loop(func)
    while taskwait(0.03) do func() end
end

function api:PlayAgain()
    while not env.isroundover do taskwait(0.1) end
    env.lasttime = ostime()
    env.timer = 0
    env.waveinfo = 1
    taskwait(1)
    if bytenet and bytenet.RoundResult and bytenet.RoundResult.VoteForRestart and bytenet.RoundResult.VoteForRestart.send then
        pcall(function() bytenet.RoundResult.VoteForRestart.send(true) end)
    end
    updatelog("Restart requested")
end

return api
