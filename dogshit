-- Full API: Guaranteed-upgrade version
local replicatedstorage = game:GetService("ReplicatedStorage")

local library = loadstring(game:HttpGet('https://raw.githubusercontent.com/ovoch228/depthsoimgui/refs/heads/main/library'))()
local bytenet = require(replicatedstorage:WaitForChild("Teawork"):WaitForChild("Shared"):WaitForChild("Services"):WaitForChild("ByteNetworking"))

local api = {}

local FAST_WAIT = 0.03

function api:Loadout(towers)
	if game.PlaceId ~= 98936097545088 then return end
	for i = 1, #towers do
		local attempt = 0
		while true do
			if getgenv().isroundover then return end
			attempt = attempt + 1
			local ok, res = pcall(function()
				return bytenet.Inventory.EquipTower.invoke({["TowerID"] = towers[i], ["Slot"] = i})
			end)
			if ok then
				updatelog("Loadout: Equipped " .. tostring(towers[i]) .. " (slot " .. tostring(i) .. ") after " .. tostring(attempt) .. " attempt(s)")
				break
			else
				updatelog("Loadout: Equip failed for " .. tostring(towers[i]) .. " attempt " .. tostring(attempt) .. " - retrying")
				task.wait(FAST_WAIT)
			end
		end
		task.wait(FAST_WAIT)
	end
end

function api:Map(map, modifiers)
	if game.PlaceId ~= 98936097545088 then return end
	local attempt = 0
	while true do
		if getgenv().isroundover then return end
		attempt = attempt + 1
		local ok, res = pcall(function()
			return bytenet.MatchmakingNew.CreateSingleplayer.invoke({["Gamemode"] = "Standard", ["MapID"] = map, ["Modifiers"] = modifiers})
		end)
		if ok then
			updatelog("Map: Created singleplayer match for " .. tostring(map) .. " after " .. tostring(attempt) .. " attempt(s)")
			break
		else
			updatelog("Map: CreateSingleplayer failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

if game.PlaceId ~= 124069847780670 then return api end

local towers = bytenet.Towers
local mapinfo = replicatedstorage.RoundInfo

local roundresultui = game:GetService("Players").LocalPlayer.PlayerGui.GameUI.RoundResult

local ostime = os.time
local taskwait = task.wait
local env = getgenv()

env.StratName = env.StratName or "Strat"

env.timer = env.timer or 0 -- seconds
env.lasttime = env.lasttime or ostime()
env.waveinfo = env.waveinfo or 1
env.isroundover = env.isroundover or false

env.totalplacedtowers = env.totalplacedtowers or 0
env.firsttower = env.firsttower or 1

env.destroyui = env.destroyui or false

local window = library:CreateWindow({
	Title = "Shitty X",
	Size = UDim2.new(0, 350, 0, 370),
	Position = UDim2.new(0.5, 0, 0, 70),
	NoResize = false
})

window:Center()

local logtab = window:CreateTab({
	Name = "Macro Player",
	Visible = true
})

local filename = logtab:Label({
	Text = "StratName: " .. env.StratName
})

local logstab = window:CreateTab({
	Name = "Logs",
	Visible = true
})

local loglabel = logtab:Label({
	Label = "Last Log: Voting"
})

local row = logstab:Row()

logstab:Separator({
	Text = "Logs:"
})

local logs = logstab:Console({
	Text = "",
	ReadOnly = true,
	LineNumbers = false,
	Border = false,
	Fill = true,
	Enabled = true,
	AutoScroll = true,
	RichText = true,
	MaxLines = 200
})

function updatelog(text)
	setthreadidentity(7)
	logs:AppendText(DateTime.now():FormatLocalTime("HH:mm:ss", "en-us") .. ": " .. tostring(text))
	loglabel:SetText("Last Log: " .. tostring(text))
end

window:ShowTab(logtab)
updatelog("Voting")

function waitTime(time, wave)
	while env.waveinfo < wave and not env.isroundover do
		task.wait(FAST_WAIT)
	end
	while env.timer < time and not env.isroundover do
		task.wait(FAST_WAIT)
	end
	return not env.isroundover
end

function api:Loop(func)
	if game.PlaceId ~= 124069847780670 then return end
	while task.wait(FAST_WAIT) do
		func()
	end
end

function api:Start()
	bytenet.Timescale.SetTimescale.send(3)

	env.waveinfo = mapinfo:GetAttribute("Wave") or 1
	env.timer = 0

	mapinfo:GetAttributeChangedSignal("Wave"):Connect(function()
		env.waveinfo = mapinfo:GetAttribute("Wave")
	end)

	roundresultui:GetPropertyChangedSignal("Visible"):Connect(function()
		env.isroundover = roundresultui.Visible
	end)

	updatelog("Game Started")

	task.spawn(function()
		env.lasttime = ostime()
		while env.lasttime do
			env.timer = (ostime() - env.lasttime) * 3
			task.wait(0.25)
		end
	end)
end

function api:Difficulty(diff)
	updatelog("Voted difficulty " .. tostring(diff))
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, err = pcall(function() bytenet.DifficultyVote.Vote.send(diff) end)
		if ok then
			updatelog("Difficulty vote sent after " .. tostring(attempt) .. " attempt(s)")
			break
		else
			updatelog("Difficulty vote failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end

	while #mapinfo:GetAttribute("Difficulty") == 0 and not env.isroundover do
		task.wait(FAST_WAIT)
	end

	env.lasttime = ostime()
	env.timer = 0
	env.waveinfo = 1

	task.wait(FAST_WAIT)
end

function api:Ready(time, wave)
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, err = pcall(function() bytenet.ReadyVote.Vote.send(true) end)
		if ok then
			updatelog("Sent ready vote after " .. tostring(attempt) .. " attempt(s)")
			break
		else
			updatelog("Ready vote failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

function api:Skip(time, wave)
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, err = pcall(function() replicatedstorage:WaitForChild("ByteNetReliable"):FireServer(buffer.fromstring("\148\001")) end)
		if ok then
			updatelog("Skip sent after " .. tostring(attempt) .. " attempt(s)")
			break
		else
			updatelog("Skip failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

function api:AutoSkip(enable, time, wave)
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, err = pcall(function() bytenet.SkipWave.ToggleAutoSkip.send(enable) end)
		if ok then
			updatelog("AutoSkip set to " .. tostring(enable) .. " after " .. tostring(attempt) .. " attempt(s)")
			break
		else
			updatelog("AutoSkip failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

function api:Place(tower, position, time, wave)
	env.totalplacedtowers = env.totalplacedtowers + 1
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, res = pcall(function()
			return towers.PlaceTower.invoke({["Position"] = position, ["Rotation"] = 0, ["TowerID"] = tower})
		end)
		if ok then
			if type(res) == "table" then
				if res.Success == true then
					updatelog("Placed Tower " .. tostring(tower) .. " (attempt " .. tostring(attempt) .. ")")
					break
				else
					updatelog("Place returned failure; retrying (attempt " .. tostring(attempt) .. ")")
					task.wait(FAST_WAIT)
				end
			else
				updatelog("Placed Tower " .. tostring(tower) .. " (attempt " .. tostring(attempt) .. ")")
				break
			end
		else
			updatelog("Place invocation error attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

-- GUARANTEED: do not return until server confirms targetLevel reached
function api:Upgrade(tower, targetLevel, time, wave)
	-- compute real index
	local realindex = env.firsttower + (tower - 1)

	-- defensive: if targetLevel not provided, assume +1 upgrade target (make sure we still guarantee)
	if not targetLevel or type(targetLevel) ~= "number" then
		targetLevel = nil -- we'll treat nil as "wait for any successful upgrade to be confirmed at least once"
	end

	local attempt = 0
	local lastReportedLevel = nil

	while not env.isroundover do
		attempt = attempt + 1

		local ok, res = pcall(function()
			return towers.UpgradeTower.invoke(realindex)
		end)

		if not ok then
			updatelog("Upgrade invocation error on tower " .. tostring(tower) .. " (attempt " .. tostring(attempt) .. ") - retrying")
			task.wait(FAST_WAIT)
			goto continue_upgrade_retry
		end

		-- ok == true, res could be table or non-table
		if type(res) == "table" then
			-- If server returned a Level, use it
			if res.Level ~= nil then
				lastReportedLevel = res.Level
				updatelog("Upgrade attempt on tower " .. tostring(tower) .. " reported level " .. tostring(lastReportedLevel) .. " (attempt " .. tostring(attempt) .. ")")
				-- If we have a targetLevel, check it
				if targetLevel then
					if lastReportedLevel >= targetLevel then
						updatelog("Upgrade COMPLETE: tower " .. tostring(tower) .. " reached level " .. tostring(lastReportedLevel) .. " (target " .. tostring(targetLevel) .. ")")
						return
					else
						-- not yet at target, continue looping (will attempt further upgrades)
						task.wait(FAST_WAIT)
						goto continue_upgrade_retry
					end
				else
					-- No numeric target: treat presence of a reported level after a successful invoke as confirmation of an upgrade (done)
					updatelog("Upgrade CONFIRMED: tower " .. tostring(tower) .. " level " .. tostring(lastReportedLevel) .. " (attempt " .. tostring(attempt) .. ")")
					return
				end
			end

			-- If server returned Success but no Level field, we must authoritative-poll until we see a level change.
			if res.Success == true and res.Level == nil then
				updatelog("Upgrade reported success but no level yet for tower " .. tostring(tower) .. " (attempt " .. tostring(attempt) .. "). Polling for authoritative level...")
				-- Start polling loop: keep invoking UpgradeTower.invoke to get authoritative level data or until we detect level >= target
				local pollAttempt = 0
				while not env.isroundover do
					pollAttempt = pollAttempt + 1
					local ok2, res2 = pcall(function()
						return towers.UpgradeTower.invoke(realindex)
					end)
					if ok2 and type(res2) == "table" and res2.Level ~= nil then
						lastReportedLevel = res2.Level
						updatelog("Poll: tower " .. tostring(tower) .. " level now " .. tostring(lastReportedLevel) .. " (poll attempt " .. tostring(pollAttempt) .. ")")
						if targetLevel then
							if lastReportedLevel >= targetLevel then
								updatelog("Upgrade COMPLETE via poll: tower " .. tostring(tower) .. " reached level " .. tostring(lastReportedLevel))
								return
							else
								-- not at target yet — continue outer loop to attempt more upgrades
								break
							end
						else
							-- no numeric target provided; confirmation achieved
							updatelog("Upgrade CONFIRMED via poll for tower " .. tostring(tower) .. " (level " .. tostring(lastReportedLevel) .. ")")
							return
						end
					end
					-- poll failed or no level yet: wait very briefly then try again
					task.wait(FAST_WAIT)
				end
				-- continue to outer retry loop to attempt again (if needed)
				goto continue_upgrade_retry
			end

			-- If Success == false, log reason and retry
			if res.Success == false then
				local reason = res.FailReason or "Unknown"
				updatelog("Upgrade failed for tower " .. tostring(tower) .. " (" .. tostring(reason) .. ") attempt " .. tostring(attempt) .. " - retrying")
				task.wait(FAST_WAIT)
				goto continue_upgrade_retry
			end
		else
			-- Non-table response: treat as ambiguous success — poll to verify
			updatelog("Upgrade returned ambiguous response for tower " .. tostring(tower) .. " (attempt " .. tostring(attempt) .. "), polling for confirmation")
			local pollAttempt2 = 0
			while not env.isroundover do
				pollAttempt2 = pollAttempt2 + 1
				local ok3, res3 = pcall(function()
					return towers.UpgradeTower.invoke(realindex)
				end)
				if ok3 and type(res3) == "table" and res3.Level ~= nil then
					lastReportedLevel = res3.Level
					updatelog("Poll2: tower " .. tostring(tower) .. " level " .. tostring(lastReportedLevel) .. " (poll attempt " .. tostring(pollAttempt2) .. ")")
					if targetLevel then
						if lastReportedLevel >= targetLevel then
							updatelog("Upgrade COMPLETE via poll2: tower " .. tostring(tower) .. " reached level " .. tostring(lastReportedLevel))
							return
						else
							break
						end
					else
						updatelog("Upgrade CONFIRMED via poll2 for tower " .. tostring(tower) .. " (level " .. tostring(lastReportedLevel) .. ")")
						return
					end
				end
				task.wait(FAST_WAIT)
			end
		end

		::continue_upgrade_retry::
		-- tiny yield before next attempt
		task.wait(FAST_WAIT)
	end

	-- if loop exits because round ended, log that upgrade was aborted by round end
	updatelog("Upgrade aborted for tower " .. tostring(tower) .. " because round ended")
end

function api:SetTarget(tower, target, time, wave)
	local realindex = env.firsttower + (tower - 1)
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, err = pcall(function() towers.SetTargetMode.send({["UID"] = (realindex), ["TargetMode"] = target}) end)
		if ok then
			updatelog("Changed Tower " .. tostring(tower) .. " Target to " .. tostring(target) .. " (attempt " .. tostring(attempt) .. ")")
			break
		else
			updatelog("SetTarget failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

function api:Sell(tower, time, wave)
	local realindex = env.firsttower + (tower - 1)
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, res = pcall(function() return towers.SellTower.invoke(realindex) end)
		if ok then
			updatelog("Sold Tower " .. tostring(tower) .. " (attempt " .. tostring(attempt) .. ")")
			break
		else
			updatelog("Sell failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

function api:PlayAgain()
	while not env.isroundover do task.wait(FAST_WAIT) end

	env.firsttower = env.totalplacedtowers + 1

	env.lasttime = ostime()
	env.timer = 0
	env.waveinfo = 1

	task.wait(1)

	local attempt = 0
	while true do
		attempt = attempt + 1
		local ok, err = pcall(function() bytenet.RoundResult.VoteForRestart.send(true) end)
		if ok then
			updatelog("Voted for restart after " .. tostring(attempt) .. " attempt(s)")
			break
		else
			updatelog("PlayAgain vote failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

return api
