-- Full API: Guaranteed-upgrade version with original Difficulty replay restored
local replicatedstorage = game:GetService("ReplicatedStorage")

local library = loadstring(game:HttpGet('https://raw.githubusercontent.com/ovoch228/depthsoimgui/refs/heads/main/library'))()
local bytenet = require(replicatedstorage:WaitForChild("Teawork"):WaitForChild("Shared"):WaitForChild("Services"):WaitForChild("ByteNetworking"))

local api = {}
local FAST_WAIT = 0.03

if game.PlaceId ~= 124069847780670 then return api end

local towers = bytenet.Towers
local mapinfo = replicatedstorage.RoundInfo
local roundresultui = game:GetService("Players").LocalPlayer.PlayerGui.GameUI.RoundResult
local env = getgenv()

env.totalplacedtowers = env.totalplacedtowers or 0
env.firsttower = env.firsttower or 1
env.isroundover = env.isroundover or false
env.StratName = env.StratName or "Strat"
env.timer = env.timer or 0
env.lasttime = env.lasttime or os.time()
env.waveinfo = env.waveinfo or 1
env.destroyui = env.destroyui or false

roundresultui:GetPropertyChangedSignal("Visible"):Connect(function()
	env.isroundover = roundresultui.Visible
end)

local window = library:CreateWindow({
	Title = "Shitty X",
	Size = UDim2.new(0, 350, 0, 370),
	Position = UDim2.new(0.5, 0, 0, 70),
	NoResize = false
})
window:Center()

local logtab = window:CreateTab({ Name = "Macro Player", Visible = true })
local filename = logtab:Label({ Text = "StratName: " .. env.StratName })

local logstab = window:CreateTab({ Name = "Logs", Visible = true })
local loglabel = logtab:Label({ Label = "Last Log: Voting" })

local row = logstab:Row()
logstab:Separator({ Text = "Logs:" })

local logs = logstab:Console({
	Text = "",
	ReadOnly = true,
	LineNumbers = false,
	Border = false,
	Fill = true,
	Enabled = true,
	AutoScroll = true,
	RichText = true,
	MaxLines = 200
})

function updatelog(text)
	setthreadidentity(7)
	logs:AppendText(DateTime.now():FormatLocalTime("HH:mm:ss", "en-us") .. ": " .. tostring(text))
	loglabel:SetText("Last Log: " .. tostring(text))
end

window:ShowTab(logtab)
updatelog("Voting")

function waitTime(time, wave)
	while env.waveinfo < wave and not env.isroundover do
		task.wait(FAST_WAIT)
	end
	while env.timer < time and not env.isroundover do
		task.wait(FAST_WAIT)
	end
	return not env.isroundover
end

function api:Loop(func)
	if game.PlaceId ~= 124069847780670 then return end
	while task.wait(FAST_WAIT) do
		func()
	end
end

function api:Start()
	bytenet.Timescale.SetTimescale.send(3)

	env.waveinfo = mapinfo:GetAttribute("Wave") or 1
	env.timer = 0

	mapinfo:GetAttributeChangedSignal("Wave"):Connect(function()
		env.waveinfo = mapinfo:GetAttribute("Wave")
	end)

	roundresultui:GetPropertyChangedSignal("Visible"):Connect(function()
		env.isroundover = roundresultui.Visible
	end)

	updatelog("Game Started")

	task.spawn(function()
		env.lasttime = os.time()
		while env.lasttime do
			env.timer = (os.time() - env.lasttime) * 3
			task.wait(0.25)
		end
	end)
end

-- RESTORED: original difficulty replay behavior (only this function changed)
function api:Difficulty(diff)
	updatelog("Voted difficulty " .. tostring(diff))
	bytenet.DifficultyVote.Vote.send(diff)

	while #mapinfo:GetAttribute("Difficulty") == 0 and not env.isroundover do
		task.wait(0.05)
	end

	env.lasttime = os.time()
	env.timer = 0
	env.waveinfo = 1

	task.wait(0.1)
end

function api:Ready(time, wave)
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, err = pcall(function() bytenet.ReadyVote.Vote.send(true) end)
		if ok then
			updatelog("Sent ready vote after " .. tostring(attempt) .. " attempt(s)")
			break
		else
			updatelog("Ready vote failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

function api:Skip(time, wave)
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, err = pcall(function() replicatedstorage:WaitForChild("ByteNetReliable"):FireServer(buffer.fromstring("\148\001")) end)
		if ok then
			updatelog("Skip sent after " .. tostring(attempt) .. " attempt(s)")
			break
		else
			updatelog("Skip failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

function api:AutoSkip(enable, time, wave)
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, err = pcall(function() bytenet.SkipWave.ToggleAutoSkip.send(enable) end)
		if ok then
			updatelog("AutoSkip set to " .. tostring(enable) .. " after " .. tostring(attempt) .. " attempt(s)")
			break
		else
			updatelog("AutoSkip failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

function api:Place(tower, position, time, wave)
	env.totalplacedtowers = env.totalplacedtowers + 1
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, res = pcall(function()
			return towers.PlaceTower.invoke({["Position"] = position, ["Rotation"] = 0, ["TowerID"] = tower})
		end)
		if ok then
			if type(res) == "table" then
				if res.Success == true then
					updatelog("Placed Tower " .. tostring(tower) .. " (attempt " .. tostring(attempt) .. ")")
					break
				else
					updatelog("Place returned failure; retrying (attempt " .. tostring(attempt) .. ")")
					task.wait(FAST_WAIT)
				end
			else
				updatelog("Placed Tower " .. tostring(tower) .. " (attempt " .. tostring(attempt) .. ")")
				break
			end
		else
			updatelog("Place invocation error attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

-- GUARANTEED: do not return until server confirms targetLevel reached
function api:Upgrade(tower, targetLevel, time, wave)
	local realindex = env.firsttower + (tower - 1)

	if not targetLevel or type(targetLevel) ~= "number" then
		targetLevel = nil
	end

	local attempt = 0
	local lastReportedLevel = nil

	while not env.isroundover do
		attempt = attempt + 1

		local ok, res = pcall(function()
			return towers.UpgradeTower.invoke(realindex)
		end)

		if not ok then
			updatelog("Upgrade invocation error on tower " .. tostring(tower) .. " (attempt " .. tostring(attempt) .. ") - retrying")
			task.wait(FAST_WAIT)
			goto continue_upgrade_retry
		end

		if type(res) == "table" then
			if res.Level ~= nil then
				lastReportedLevel = res.Level
				updatelog("Upgrade attempt on tower " .. tostring(tower) .. " reported level " .. tostring(lastReportedLevel) .. " (attempt " .. tostring(attempt) .. ")")
				if targetLevel then
					if lastReportedLevel >= targetLevel then
						updatelog("Upgrade COMPLETE: tower " .. tostring(tower) .. " reached level " .. tostring(lastReportedLevel) .. " (target " .. tostring(targetLevel) .. ")")
						return
					else
						task.wait(FAST_WAIT)
						goto continue_upgrade_retry
					end
				else
					updatelog("Upgrade CONFIRMED: tower " .. tostring(tower) .. " level " .. tostring(lastReportedLevel) .. " (attempt " .. tostring(attempt) .. ")")
					return
				end
			end

			if res.Success == true and res.Level == nil then
				updatelog("Upgrade reported success but no level yet for tower " .. tostring(tower) .. " (attempt " .. tostring(attempt) .. "). Polling for authoritative level...")
				local pollAttempt = 0
				while not env.isroundover do
					pollAttempt = pollAttempt + 1
					local ok2, res2 = pcall(function()
						return towers.UpgradeTower.invoke(realindex)
					end)
					if ok2 and type(res2) == "table" and res2.Level ~= nil then
						lastReportedLevel = res2.Level
						updatelog("Poll: tower " .. tostring(tower) .. " level now " .. tostring(lastReportedLevel) .. " (poll attempt " .. tostring(pollAttempt) .. ")")
						if targetLevel then
							if lastReportedLevel >= targetLevel then
								updatelog("Upgrade COMPLETE via poll: tower " .. tostring(tower) .. " reached level " .. tostring(lastReportedLevel))
								return
							else
								break
							end
						else
							updatelog("Upgrade CONFIRMED via poll for tower " .. tostring(tower) .. " (level " .. tostring(lastReportedLevel) .. ")")
							return
						end
					end
					task.wait(FAST_WAIT)
				end
				goto continue_upgrade_retry
			end

			if res.Success == false then
				local reason = res.FailReason or "Unknown"
				updatelog("Upgrade failed for tower " .. tostring(tower) .. " (" .. tostring(reason) .. ") attempt " .. tostring(attempt) .. " - retrying")
				task.wait(FAST_WAIT)
				goto continue_upgrade_retry
			end
		else
			updatelog("Upgrade returned ambiguous response for tower " .. tostring(tower) .. " (attempt " .. tostring(attempt) .. "), polling for confirmation")
			local pollAttempt2 = 0
			while not env.isroundover do
				pollAttempt2 = pollAttempt2 + 1
				local ok3, res3 = pcall(function()
					return towers.UpgradeTower.invoke(realindex)
				end)
				if ok3 and type(res3) == "table" and res3.Level ~= nil then
					lastReportedLevel = res3.Level
					updatelog("Poll2: tower " .. tostring(tower) .. " level " .. tostring(lastReportedLevel) .. " (poll attempt " .. tostring(pollAttempt2) .. ")")
					if targetLevel then
						if lastReportedLevel >= targetLevel then
							updatelog("Upgrade COMPLETE via poll2: tower " .. tostring(tower) .. " reached level " .. tostring(lastReportedLevel))
							return
						else
							break
						end
					else
						updatelog("Upgrade CONFIRMED via poll2 for tower " .. tostring(tower) .. " (level " .. tostring(lastReportedLevel) .. ")")
						return
					end
				end
				task.wait(FAST_WAIT)
			end
		end

		::continue_upgrade_retry::
		task.wait(FAST_WAIT)
	end

	updatelog("Upgrade aborted for tower " .. tostring(tower) .. " because round ended")
end

function api:SetTarget(tower, target, time, wave)
	local realindex = env.firsttower + (tower - 1)
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, err = pcall(function() towers.SetTargetMode.send({["UID"] = (realindex), ["TargetMode"] = target}) end)
		if ok then
			updatelog("Changed Tower " .. tostring(tower) .. " Target to " .. tostring(target) .. " (attempt " .. tostring(attempt) .. ")")
			break
		else
			updatelog("SetTarget failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

function api:Sell(tower, time, wave)
	local realindex = env.firsttower + (tower - 1)
	local attempt = 0
	while not env.isroundover do
		attempt = attempt + 1
		local ok, res = pcall(function() return towers.SellTower.invoke(realindex) end)
		if ok then
			updatelog("Sold Tower " .. tostring(tower) .. " (attempt " .. tostring(attempt) .. ")")
			break
		else
			updatelog("Sell failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

function api:PlayAgain()
	while not env.isroundover do task.wait(FAST_WAIT) end

	env.firsttower = env.totalplacedtowers + 1
	env.lasttime = os.time()
	env.timer = 0
	env.waveinfo = 1

	task.wait(1)

	local attempt = 0
	while true do
		attempt = attempt + 1
		local ok, err = pcall(function() bytenet.RoundResult.VoteForRestart.send(true) end)
		if ok then
			updatelog("Voted for restart after " .. tostring(attempt) .. " attempt(s)")
			break
		else
			updatelog("PlayAgain vote failed attempt " .. tostring(attempt) .. " - retrying")
			task.wait(FAST_WAIT)
		end
	end
end

return api
